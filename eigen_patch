diff --git a/Eigen/src/Core/util/ForwardDeclarations.h b/Eigen/src/Core/util/ForwardDeclarations.h
index 2f9cc4491..223ee31b8 100644
--- a/Eigen/src/Core/util/ForwardDeclarations.h
+++ b/Eigen/src/Core/util/ForwardDeclarations.h
@@ -267,6 +267,7 @@ template<typename MatrixType, int Direction = BothDirections> class Reverse;
 
 template<typename MatrixType> class FullPivLU;
 template<typename MatrixType> class PartialPivLU;
+template<typename MatrixType> class KLU;
 namespace internal {
 template<typename MatrixType> struct inverse_impl;
 }
diff --git a/Eigen/src/KLUSupport/KLUSupport.h b/Eigen/src/KLUSupport/KLUSupport.h
index 215db35b0..ae5d0df35 100644
--- a/Eigen/src/KLUSupport/KLUSupport.h
+++ b/Eigen/src/KLUSupport/KLUSupport.h
@@ -205,10 +205,35 @@ class KLU : public SparseSolverBase<KLU<_MatrixType> >
         klu_free_numeric(&m_numeric,&m_common);
 
       grab(matrix.derived());
-
+      if(m_symbolic->nz != mp_matrix.nonZeros()){
+        analyzePattern_impl();
+      }
       factorize_impl();
     }
 
+    /** Performs a numeric re-decomposition of \a matrix
+      *
+      * The given matrix must has the same sparcity than the matrix on which the pattern anylysis has been performed.
+      * The pivoting values are chosen the same
+      *
+      * \sa analyzePattern(), compute()
+      */
+    template<typename InputMatrixType>
+    void refactorize(const InputMatrixType& matrix)
+    {
+      eigen_assert(m_analysisIsOk && "KLU: you must first call analyzePattern()");
+      if(m_numeric)
+        klu_free_numeric(&m_numeric,&m_common);
+
+      grab(matrix.derived());
+      if(m_symbolic->nz != mp_matrix.nonZeros()){
+        analyzePattern_impl();
+        factorize_impl();
+      } else {
+        refactorize_impl();
+      }
+    }
+
     /** \internal */
     template<typename BDerived,typename XDerived>
     bool _solve_impl(const MatrixBase<BDerived> &b, MatrixBase<XDerived> &x) const;
@@ -237,6 +262,7 @@ class KLU : public SparseSolverBase<KLU<_MatrixType> >
       m_info = InvalidInput;
       m_analysisIsOk = false;
       m_factorizationIsOk = false;
+      m_refactorizationIsOk = false;
       m_symbolic = klu_analyze(internal::convert_index<int>(mp_matrix.rows()),
                                      const_cast<StorageIndex*>(mp_matrix.outerIndexPtr()), const_cast<StorageIndex*>(mp_matrix.innerIndexPtr()),
                                      &m_common);
@@ -260,6 +286,18 @@ class KLU : public SparseSolverBase<KLU<_MatrixType> >
       m_extractedDataAreDirty = true;
     }
 
+    void refactorize_impl()
+    {
+
+      int m_refact = klu_refactor(const_cast<StorageIndex*>(mp_matrix.outerIndexPtr()), const_cast<StorageIndex*>(mp_matrix.innerIndexPtr()), const_cast<Scalar*>(mp_matrix.valuePtr()),
+                                    m_symbolic, m_numeric, &m_common/*, Scalar()*/);
+
+
+      m_info = m_refact ? Success : NumericalIssue;
+      m_refactorizationIsOk = m_refact ? 1 : 0;
+      m_extractedDataAreDirty = true;
+    }
+
     template<typename MatrixDerived>
     void grab(const EigenBase<MatrixDerived> &A)
     {
@@ -292,6 +330,7 @@ class KLU : public SparseSolverBase<KLU<_MatrixType> >
     klu_common m_common;
     mutable ComputationInfo m_info;
     int m_factorizationIsOk;
+    int m_refactorizationIsOk;
     int m_analysisIsOk;
     mutable bool m_extractedDataAreDirty;
 
